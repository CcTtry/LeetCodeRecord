<!-- TOC -->

- [75. 颜色分类](#75-颜色分类)
  - [概述](#概述)
  - [考察的知识点](#考察的知识点)
  - [题目描述](#题目描述)
  - [示例：](#示例)
  - [进阶：](#进阶)
  - [思路](#思路)
  - [源代码](#源代码)
  - [执行结果](#执行结果)
  - [简要分析](#简要分析)
  - [单词遍历的方法](#单词遍历的方法)
    - [思路](#思路-1)
    - [不同思路源代码](#不同思路源代码)

<!-- /TOC -->
## 75. 颜色分类

### 概述

### 考察的知识点
1. 初阶思路没有课考察的知识点，就是简单的计数和赋值操作。
2. 进阶的想法：使用快拍的思想，使用三个指针对数组进行遍历和赋值


### 题目描述
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

**说明:** 
### 示例：

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
### 进阶：
```
一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？
```

<!-- -->
### 思路
代码通常写法可以分成X个部分：
    1. 
    2. 
【<font color = red>强调部分</font>】
### 源代码
```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 方法1 通过计数使用
        // 使用双指针的做法，头指针记录当前的位置，尾指针记录当已经放进
        const int n = nums.size();
        int num0 = 0, num1 = 0;
        for(int i=0; i<n; i++) {
            if(nums[i] == 0) num0 ++;
            else if(nums[i] == 1) num1 ++;
        }

        for(int i=0; i<num0; i++){
            nums[i] = 0;
        }

        for(int i=num0; i<num0+num1; i++){
            nums[i] = 1;
        }

        for(int i=num0+num1; i<n; i++){
            nums[i] = 2;
        }
    }
};
```
### 执行结果
![](./images/75%20result_sortColors.png)
###  简要分析
使用一趟扫描，一趟赋值的方法进行操作，算法复杂度为O(2n)。


### 单词遍历的方法
#### 思路
使用单个指针变量，num0，num2，i分别表示
- num0：左起第一个不为零的元素下标
- num2：从右往左 第一个不等于2的元素下标
- 遍历的下标
遍历的过程中，不断变化num0、i以及num2的数值（类似快速排序的思想）
#### 不同思路源代码
```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 方法2 
        const int n = nums.size();
        int num0 = 0, i = 0, num2 = n-1;
        while(i<n && i<= num2 && num0 <= num2) {
            if(nums[i] == 0){
                if(i == num0){
                    num0 ++;
                    i++;
                }
                else{
                    swap(nums[num0], nums[i]);
                    num0 ++;
                }
                // printf("num0=%d\n", num0);

            }else if(nums[i] == 1){//
                i ++;
                // printf("i=%d\n", i);

            }else if(nums[i] == 2){
                if(nums[num2] == 2){
                    num2 --;
                }else{
                    swap(nums[num2], nums[i]);
                    num2 --;
                }
                // printf("num2=%d\n", num2);
            }
        }
    }
};
```


