<!-- TOC -->

- [91. 解码方法](#91-解码方法)
  - [考察的知识点](#考察的知识点)
  - [题目描述](#题目描述)
  - [示例：](#示例)
  - [思路](#思路)
  - [源代码](#源代码)
  - [执行结果](#执行结果)
  - [简要分析](#简要分析)

<!-- /TOC -->
## 91. 解码方法

### 考察的知识点
1. 动态规划
2. 与爬楼梯的解法有点类似，在爬楼梯的基础上，添加了几个限制条件。


### 题目描述

一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
给定一个只包含数字的非空字符串，请计算解码方法的总数。
题目数据保证答案肯定是一个 32 位的整数。

### 示例：

**示例 1：**
```
输入："12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**
```
输入："226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**
```
输入：s = "0"
输出：0
```

**示例 4：**
```
输入：s = "1"
输出：1
```

**示例 5：**
```
输入：s = "2"
输出：1
```

提示：
```
1 <= s.length <= 100
s 只包含数字，并且可以包含前导零。
```

<!-- -->
### 思路
本题使用动态规划的方法进行解答，将问题分解为$dp[i]$ = $dp[i-1] + dp[i-2]$： 其中$dp[i]$ 表示前$i$个字符编码方法的总数。

【<font color = red>值得注意的是，当末尾为0的时候，需要考虑不同的情况</font>】
```C++
if (s[i] == '0') {
    if (s[i-1] == '1' || s[i-1] == '2'):
        dp[i] = dp[i-2];
    else{ // 越界了无法表示 's[i-1]0'
        return 0;
    }
}
else{
    if(s[i-1] == '1' || (s[i-1] == 2 && s[i] >= '1' && s[i] <= '6')){
        dp[i] = dp[i-2] + dp[i-1];
    }else{
        dp[i] = dp[i-1];
    }
}
```


### 源代码
```C++
class Solution {
public:
    int numDecodings(string s) {
        const int n = s.size();
        if(n==0) return 0;
        if(n==1) return s[0]=='0'?0:1;
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = s[0]=='0'?0:1;  // dp[1] = 1
        // dp[2] = 
        for(int i=1; i<n; i++){
            if(s[i] == '0'){
                if(s[i-1] == '1' || s[i-1]== '2'){
                    // printf("10 || 20 \n");
                    dp[i+1] = dp[i-1];
                }
                else{
                    return 0;
                }
            }
            else if(s[i-1] == '1' || (s[i-1]== '2' && s[i] >= '1' && s[i] <= '6')){
                dp[i+1] = dp[i] + dp[i-1];
            }else{
                dp[i+1] = dp[i];
            }
        }
        return dp[n];

    }
};
```
### 执行结果
![](./images/91%20result_numDecodings.png)
###  简要分析
